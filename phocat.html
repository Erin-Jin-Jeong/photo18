<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tr√¨nh Ch·ªânh S·ª≠a ·∫¢nh Th√¥ng Minh</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap"
      rel="stylesheet"
    />
    <style>
      /* Thi·∫øt l·∫≠p font Inter cho giao di·ªán */
      body {
        font-family: "Inter", sans-serif;
        background-color: #f3f4f6;
      }
      /* Custom scrollbar for better aesthetics */
      ::-webkit-scrollbar {
        width: 8px;
      }
      ::-webkit-scrollbar-track {
        background: #e5e7eb;
      }
      ::-webkit-scrollbar-thumb {
        background: #9ca3af;
        border-radius: 4px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #6b7280;
      }

      /* Canvas container styles */
      #previewContainer {
        min-height: 400px;
        display: flex;
        justify-content: center;
        align-items: center;
        background-color: #e5e7eb;
        border: 2px dashed #9ca3af;
        border-radius: 0.75rem;
        overflow: hidden;
        position: relative;
      }
      #imageCanvas {
        max-width: 100%;
        max-height: 100%;
        display: none; /* Hidden until image is loaded */
      }
      .control-group {
        @apply flex flex-col space-y-2 p-4 bg-white rounded-xl shadow-lg transition duration-300 hover:shadow-xl;
      }
      .btn-primary {
        @apply bg-indigo-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md hover:bg-indigo-700 transition duration-150 ease-in-out;
      }
      .btn-secondary {
        @apply bg-gray-200 text-gray-800 font-semibold py-2 px-4 rounded-lg shadow-md hover:bg-gray-300 transition duration-150 ease-in-out;
      }
      /* Styles for the loading spinner */
      .spinner {
        border: 4px solid rgba(255, 255, 255, 0.3);
        border-top: 4px solid #ffffff;
        border-radius: 50%;
        width: 30px;
        height: 30px;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
      .ai-result {
        aspect-ratio: 1/1;
        background-color: #1f2937;
        border-radius: 0.75rem;
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: hidden;
        position: relative;
      }
      .visible {
        visibility: visible;
      }
      .invisible {
        visibility: hidden;
      }
    </style>
  </head>
  <body class="p-4 md:p-8">
    <div class="max-w-6xl mx-auto">
      <h1 class="text-3xl font-extrabold text-gray-900 mb-6 border-b pb-2">
        üñºÔ∏è Tr√¨nh Ch·ªânh S·ª≠a ·∫¢nh Th√¥ng Minh
      </h1>

      <div id="editor-section" class="grid grid-cols-1 lg:grid-cols-3 gap-8">
        <!-- C·ªôt 1: Controls -->
        <div class="lg:col-span-1 space-y-6">
          <!-- Nh√≥m 1: T·∫£i ·∫¢nh v√† T·∫£i Xu·ªëng -->
          <div class="control-group">
            <h2 class="text-xl font-semibold mb-3 text-indigo-600">
              1. Qu·∫£n L√Ω ·∫¢nh
            </h2>
            <label
              for="imageUpload"
              class="btn-primary block text-center cursor-pointer"
            >
              Ch·ªçn v√† T·∫£i ·∫¢nh L√™n
            </label>
            <input
              type="file"
              id="imageUpload"
              accept="image/*"
              class="hidden"
              onchange="handleImageUpload(event)"
            />

            <button
              id="downloadBtn"
              class="btn-secondary w-full opacity-50 cursor-not-allowed"
              disabled
              onclick="downloadImage()"
            >
              üì• T·∫£i ·∫¢nh ƒê√£ Ch·ªânh S·ª≠a
            </button>
            <select
              id="downloadFormat"
              class="w-full p-2 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500"
            >
              <option value="image/png">PNG</option>
              <option value="image/jpeg">JPEG</option>
              <option value="image/gif">GIF</option>
              <option value="image/webp">WEBP</option>
            </select>
          </div>

          <!-- Nh√≥m 2: ƒêi·ªÅu Ch·ªânh C∆° B·∫£n -->
          <div class="control-group">
            <h2 class="text-xl font-semibold mb-3 text-indigo-600">
              2. ƒêi·ªÅu Ch·ªânh C∆° B·∫£n
            </h2>

            <div id="controls-list" class="space-y-4">
              <div class="flex flex-col">
                <label
                  for="brightness"
                  class="font-medium text-gray-700 flex justify-between"
                  >ƒê·ªô S√°ng:</label
                >
                <div class="flex items-center space-x-2">
                  <input
                    type="number"
                    id="brightness"
                    min="0"
                    max="200"
                    value="100"
                    class="w-full p-2 border border-gray-300 rounded-lg text-sm"
                    oninput="applyFilters()"
                  />
                  <span class="text-sm text-gray-500">%</span>
                </div>
              </div>
              <div class="flex flex-col">
                <label
                  for="contrast"
                  class="font-medium text-gray-700 flex justify-between"
                  >ƒê·ªô T∆∞∆°ng Ph·∫£n:</label
                >
                <div class="flex items-center space-x-2">
                  <input
                    type="number"
                    id="contrast"
                    min="0"
                    max="200"
                    value="100"
                    class="w-full p-2 border border-gray-300 rounded-lg text-sm"
                    oninput="applyFilters()"
                  />
                  <span class="text-sm text-gray-500">%</span>
                </div>
              </div>
              <div class="flex flex-col">
                <label
                  for="blur"
                  class="font-medium text-gray-700 flex justify-between"
                  >L√†m M·ªù (Blur):</label
                >
                <div class="flex items-center space-x-2">
                  <input
                    type="number"
                    id="blur"
                    min="0"
                    max="10"
                    step="0.1"
                    value="0"
                    class="w-full p-2 border border-gray-300 rounded-lg text-sm"
                    oninput="applyFilters()"
                  />
                  <span class="text-sm text-gray-500">px</span>
                </div>
              </div>
            </div>
          </div>

          <!-- Nh√≥m 3: Bi·∫øn ƒê·ªïi & C·∫Øt -->
          <div class="control-group">
            <h2 class="text-xl font-semibold mb-3 text-indigo-600">
              3. Bi·∫øn ƒê·ªïi & C·∫Øt
            </h2>
            <div class="grid grid-cols-2 gap-3">
              <button class="btn-secondary" onclick="applyGrayscale()">
                ‚ö´ Chuy·ªÉn ƒêen Tr·∫Øng
              </button>
              <button class="btn-secondary" onclick="resetFilters()">
                üîÑ ƒê·∫∑t L·∫°i Hi·ªáu ·ª®ng
              </button>
              <button class="btn-secondary" onclick="rotateImage(90)">
                ‚Ü©Ô∏è Xoay (90¬∞)
              </button>
              <button class="btn-secondary" onclick="flipImage('horizontal')">
                ‚ÜîÔ∏è L·∫≠t Ngang
              </button>

              <button
                id="cropModeBtn"
                class="btn-secondary col-span-2"
                onclick="toggleCropMode()"
              >
                ‚úÇÔ∏è Ch·∫ø ƒê·ªô C·∫Øt
              </button>
              <button
                id="applyCropBtn"
                class="btn-primary col-span-2 opacity-50 cursor-not-allowed"
                disabled
                onclick="performCrop()"
              >
                ‚úÖ √Åp D·ª•ng C·∫Øt
              </button>
            </div>
          </div>

          <!-- Nh√≥m 4: Th√™m Ch·ªØ v√† N·ªÅn -->
          <div class="control-group">
            <h2 class="text-xl font-semibold mb-3 text-indigo-600">
              4. Th√™m/S·ª≠a Ch√∫ Th√≠ch VƒÉn B·∫£n
            </h2>

            <textarea
              id="textInput"
              rows="2"
              class="w-full p-2 border border-gray-300 rounded-lg text-sm"
              placeholder="Nh·∫≠p ch·ªØ c·∫ßn th√™m/s·ª≠a..."
              oninput="syncInputsToActiveAnnotation()"
            ></textarea>

            <div class="grid grid-cols-2 gap-3">
              <div class="flex flex-col">
                <label for="fontSize" class="text-xs font-medium text-gray-700"
                  >C·ª° Ch·ªØ (px)</label
                >
                <input
                  type="number"
                  id="fontSize"
                  value="30"
                  min="10"
                  max="200"
                  class="p-2 border border-gray-300 rounded-lg text-sm"
                  oninput="syncInputsToActiveAnnotation()"
                />
              </div>
              <div class="flex flex-col">
                <label
                  for="textPositionX"
                  class="text-xs font-medium text-gray-700"
                  >V·ªã tr√≠ X</label
                >
                <input
                  type="number"
                  id="textPositionX"
                  value="50"
                  class="p-2 border border-gray-300 rounded-lg text-sm"
                  oninput="syncInputsToActiveAnnotation()"
                />
              </div>
              <div class="flex flex-col">
                <label for="textColor" class="text-xs font-medium text-gray-700"
                  >M√†u Ch·ªØ</label
                >
                <input
                  type="color"
                  id="textColor"
                  value="#FFFFFF"
                  class="h-8 p-0 border border-gray-300 rounded-lg cursor-pointer"
                  oninput="syncInputsToActiveAnnotation()"
                />
              </div>
              <div class="flex flex-col">
                <label
                  for="textPositionY"
                  class="text-xs font-medium text-gray-700"
                  >V·ªã tr√≠ Y</label
                >
                <input
                  type="number"
                  id="textPositionY"
                  value="50"
                  class="p-2 border border-gray-300 rounded-lg text-sm"
                  oninput="syncInputsToActiveAnnotation()"
                />
              </div>
            </div>
            <div class="flex flex-col">
              <label for="textBgColor" class="text-xs font-medium text-gray-700"
                >M√†u N·ªÅn Ch·ªØ (M·∫∑c ƒë·ªãnh trong su·ªët n·∫øu kh√¥ng ph·∫£i m√†u ƒëen)</label
              >
              <input
                type="color"
                id="textBgColor"
                value="#000000"
                class="h-8 p-0 border border-gray-300 rounded-lg cursor-pointer"
                oninput="syncInputsToActiveAnnotation()"
              />
            </div>

            <button
              id="addTextBtn"
              class="btn-primary w-full"
              onclick="addTextAnnotation()"
            >
              ‚ûï Th√™m Ch√∫ Th√≠ch M·ªõi
            </button>

            <div
              id="annotation-info"
              class="p-3 bg-gray-100 rounded-lg mt-3 text-sm hidden"
            >
              <p class="font-semibold text-gray-700 mb-2">
                ƒêang ch·ªçn l·ªõp:
                <span id="activeTextId" class="font-mono text-indigo-600"
                  >Kh√¥ng</span
                >
              </p>
              <button
                id="deleteTextBtn"
                class="btn-secondary text-red-600 border border-red-300 w-full"
                onclick="deleteActiveAnnotation()"
              >
                üóëÔ∏è X√≥a L·ªõp Ch·ªØ ƒêang Ch·ªçn
              </button>
            </div>

            <p class="text-xs text-gray-500 pt-2 border-t mt-3">
              üí° **Click v√†o ch·ªØ** ƒë·ªÉ ch·ªçn v√† ch·ªânh s·ª≠a.
            </p>
          </div>
        </div>

        <!-- C·ªôt 2: Preview ·∫¢nh -->
        <div class="lg:col-span-2">
          <!-- CROP NUMERICAL INPUTS -->
          <div
            id="cropInfoInputs"
            class="grid grid-cols-4 gap-2 text-sm font-medium text-gray-700 mb-2 invisible"
          >
            <div>
              <label for="cropX" class="text-xs block">X:</label>
              <input
                type="number"
                id="cropX"
                min="0"
                value="0"
                class="w-full p-1 border border-gray-300 rounded-lg text-sm"
                oninput="updateCropRectFromInputs()"
              />
            </div>
            <div>
              <label for="cropY" class="text-xs block">Y:</label>
              <input
                type="number"
                id="cropY"
                min="0"
                value="0"
                class="w-full p-1 border border-gray-300 rounded-lg text-sm"
                oninput="updateCropRectFromInputs()"
              />
            </div>
            <div>
              <label for="cropW" class="text-xs block">R·ªông:</label>
              <input
                type="number"
                id="cropW"
                min="0"
                value="0"
                class="w-full p-1 border border-gray-300 rounded-lg text-sm"
                oninput="updateCropRectFromInputs()"
              />
            </div>
            <div>
              <label for="cropH" class="text-xs block">Cao:</label>
              <input
                type="number"
                id="cropH"
                min="0"
                value="0"
                class="w-full p-1 border border-gray-300 rounded-lg text-sm"
                oninput="updateCropRectFromInputs()"
              />
            </div>
          </div>

          <div id="previewContainer" class="w-full">
            <p
              id="placeholderText"
              class="text-gray-500 text-lg p-10 text-center"
            >
              Vui l√≤ng t·∫£i ·∫£nh l√™n ƒë·ªÉ b·∫Øt ƒë·∫ßu ch·ªânh s·ª≠a.<br />
              (·∫¢nh s·∫Ω ƒë∆∞·ª£c hi·ªÉn th·ªã v√† ch·ªânh s·ª≠a t·∫°i ƒë√¢y)
            </p>
            <canvas id="imageCanvas"></canvas>
          </div>
        </div>
      </div>

      <!-- Section: AI Image Generation -->
      <div
        class="mt-12 p-6 bg-white rounded-xl shadow-2xl border border-indigo-100"
      >
        <h2 class="text-2xl font-bold text-indigo-600 mb-4 flex items-center">
          ‚ú® T√≠nh NƒÉng Th√¥ng Minh: Ch·ªânh S·ª≠a ·∫¢nh b·∫±ng AI
        </h2>
        <p class="text-gray-600 mb-4">
          M√¥ h√¨nh AI (<span class="font-semibold text-indigo-500"
            >gemini-2.5-flash-image-preview</span
          >) s·∫Ω s·ª≠ d·ª•ng ·∫£nh hi·ªán t·∫°i tr√™n canvas l√†m ƒë·∫ßu v√†o v√† bi·∫øn ƒë·ªïi theo m√¥
          t·∫£ c·ªßa b·∫°n.
        </p>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
          <!-- Input for AI Prompt -->
          <div class="md:col-span-2 space-y-4">
            <textarea
              id="aiPrompt"
              rows="3"
              class="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500"
              placeholder="M√¥ t·∫£ s·ª± thay ƒë·ªïi b·∫°n mu·ªën (v√≠ d·ª•: Thay th·∫ø con m√®o b·∫±ng m·ªôt con ch√≥ husky, l√†m cho b·∫ßu tr·ªùi c√≥ m√†u t√≠m, phong c√°ch ngh·ªá thu·∫≠t pixel)"
            ></textarea>
            <button
              id="generateBtn"
              class="btn-primary w-full"
              onclick="generateAIImage()"
            >
              T·∫°o/Ch·ªânh S·ª≠a ·∫¢nh M·ªõi
            </button>
          </div>

          <!-- AI Result Display -->
          <div class="md:col-span-1">
            <div id="aiResult" class="ai-result">
              <p class="text-gray-400 text-sm text-center p-4">
                ·∫¢nh AI s·∫Ω xu·∫•t hi·ªán t·∫°i ƒë√¢y
              </p>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("imageCanvas");
      const ctx = canvas.getContext("2d");
      const placeholderText = document.getElementById("placeholderText");
      const downloadBtn = document.getElementById("downloadBtn");
      const downloadFormat = document.getElementById("downloadFormat");
      const cropApplyBtn = document.getElementById("applyCropBtn");
      const annotationInfoDiv = document.getElementById("annotation-info");
      const activeTextIdSpan = document.getElementById("activeTextId");

      let initialImage = null;
      let originalImage = null;
      let rotationAngle = 0;
      let flipH = 1;

      // Tr·∫°ng th√°i C·∫Øt (Crop)
      let isCropping = false;
      let cropStart = { x: 0, y: 0 };
      let cropRect = null;

      // Tr·∫°ng th√°i K√©o Ch·ªØ (Drag Text)
      let isTextDragging = false;
      let activeDragAnnotation = null; // Ch√∫ th√≠ch ƒëang ƒë∆∞·ª£c k√©o/ch·ªçn
      let dragOffsetX = 0;
      let dragOffsetY = 0;

      // M·∫£ng l∆∞u tr·ªØ T·∫§T C·∫¢ c√°c ch√∫ th√≠ch vƒÉn b·∫£n
      let annotations = [];

      // Constants for API calls
      const apiKey = "";
      const model = "gemini-2.5-flash-image-preview";

      const systemInstruction = {
        parts: [
          {
            text: "B·∫°n l√† m·ªôt chuy√™n gia ch·ªânh s·ª≠a ·∫£nh AI. Nhi·ªám v·ª• c·ªßa b·∫°n l√† l·∫•y ·∫£nh ƒë·∫ßu v√†o v√† √°p d·ª•ng c√°c thay ƒë·ªïi ƒë∆∞·ª£c m√¥ t·∫£ trong prompt c·ªßa ng∆∞·ªùi d√πng. H√£y ch√∫ √Ω ƒë·∫∑c bi·ªát ƒë·∫øn c√°c chi ti·∫øt v·ªÅ g√≥c nh√¨n (perspective), ƒë·ªô cao c·ªßa m√°y ·∫£nh (v√≠ d·ª•: 150cm-200cm), v·ªã tr√≠ trung t√¢m c·ªßa ƒë·ªëi t∆∞·ª£ng v√† c√°c y·∫øu t·ªë b·ªë c·ª•c (composition) kh√°c ƒë·ªÉ ƒë·∫£m b·∫£o k·∫øt qu·∫£ ph√π h·ª£p v·ªõi m√¥ t·∫£ nh·∫•t c√≥ th·ªÉ.",
          },
        ],
      };

      // --- H√†m Ti·ªán √çch ---

      /**
       * Chuy·ªÉn t·ªça ƒë·ªô chu·ªôt (relative to viewport) sang t·ªça ƒë·ªô Canvas (internal pixel)
       */
      function getCanvasCoords(clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;

        const x = (clientX - rect.left) * scaleX;
        const y = (clientY - rect.top) * scaleY;
        return { x, y };
      }

      // --- X·ª≠ L√Ω ·∫¢nh C∆° B·∫£n v√† B·ªô L·ªçc (Gi·ªØ nguy√™n) ---

      function handleImageUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function (e) {
          const img = new Image();
          img.onload = function () {
            initialImage = img;
            originalImage = img;
            rotationAngle = 0;
            flipH = 1;
            cropRect = null;
            isCropping = false;
            annotations = []; // Reset all annotations

            activeDragAnnotation = null;
            syncActiveAnnotationToInputs(null); // Reset annotation controls UI

            document.getElementById("brightness").value = 100;
            document.getElementById("contrast").value = 100;
            document.getElementById("blur").value = 0;
            canvas.style.filter = "";

            downloadBtn.disabled = false;
            downloadBtn.classList.remove("opacity-50", "cursor-not-allowed");
            placeholderText.style.display = "none";
            canvas.style.display = "block";

            drawCanvas(originalImage);
            applyFilters();
          };
          img.src = e.target.result;
        };
        reader.readAsDataURL(file);
      }

      function applyFilters() {
        if (!originalImage) return;
        const brightness = document.getElementById("brightness").value;
        const contrast = document.getElementById("contrast").value;
        const blur = document.getElementById("blur").value;
        const isGrayscale = canvas.style.filter.includes("grayscale(1)");

        let filterString = `brightness(${brightness}%) contrast(${contrast}%) blur(${blur}px)`;
        if (isGrayscale) {
          filterString += ` grayscale(1)`;
        }

        canvas.style.filter = filterString.trim();
        drawCanvas(originalImage);
      }

      function resetFilters() {
        if (!initialImage) return;

        document.getElementById("brightness").value = 100;
        document.getElementById("contrast").value = 100;
        document.getElementById("blur").value = 0;

        rotationAngle = 0;
        flipH = 1;

        originalImage = initialImage;

        cropRect = null;
        if (isCropping) toggleCropMode();

        activeDragAnnotation = null;
        syncActiveAnnotationToInputs(null); // Reset annotation controls UI

        canvas.style.filter = "";

        applyFilters();
        drawCanvas(originalImage);
      }

      function applyGrayscale() {
        if (!originalImage) return;
        const currentFilter = canvas.style.filter;
        if (currentFilter.includes("grayscale(1)")) {
          canvas.style.filter = currentFilter
            .replace("grayscale(1)", "")
            .trim();
        } else {
          canvas.style.filter += " grayscale(1)";
        }
        applyFilters();
      }

      function rotateImage(angle) {
        if (!originalImage) return;
        rotationAngle = (rotationAngle + angle) % 360;
        drawCanvas(originalImage);
      }

      function flipImage(axis) {
        if (!originalImage) return;
        if (axis === "horizontal") {
          flipH *= -1;
        }
        drawCanvas(originalImage);
      }

      // --- V·∫Ω Canvas ch√≠nh ---
      function drawCanvas(img) {
        if (!img) return;

        const isRotated = rotationAngle % 180 !== 0;
        const newWidth = isRotated ? img.height : img.width;
        const newHeight = isRotated ? img.width : img.height;

        canvas.width = newWidth;
        canvas.height = newHeight;

        ctx.clearRect(0, 0, newWidth, newHeight);
        ctx.save();
        ctx.translate(newWidth / 2, newHeight / 2);
        ctx.rotate((rotationAngle * Math.PI) / 180);
        ctx.scale(flipH, 1);

        let drawX = -img.width / 2;
        let drawY = -img.height / 2;
        let drawW = img.width;
        let drawH = img.height;

        ctx.drawImage(img, drawX, drawY, drawW, drawH);
        ctx.restore();

        // --- DRAW CROP OVERLAY (V·∫Ω l·ªõp ph·ªß khi c·∫Øt) ---
        if (isCropping && cropRect) {
          ctx.save();
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
          ctx.fillRect(0, 0, canvas.width, cropRect.y);
          ctx.fillRect(
            0,
            cropRect.y + cropRect.h,
            canvas.width,
            canvas.height - (cropRect.y + cropRect.h)
          );
          ctx.fillRect(0, cropRect.y, cropRect.x, cropRect.h);
          ctx.fillRect(
            cropRect.x + cropRect.w,
            cropRect.y,
            canvas.width - (cropRect.x + cropRect.w),
            cropRect.h
          );
          ctx.strokeStyle = "#FFFFFF";
          ctx.lineWidth = 2;
          ctx.setLineDash([5, 5]);
          ctx.strokeRect(cropRect.x, cropRect.y, cropRect.w, cropRect.h);
          ctx.setLineDash([]);
          ctx.restore();
        }

        // --- DRAW ANNOTATIONS (V·∫Ω t·∫•t c·∫£ ch√∫ th√≠ch vƒÉn b·∫£n) ---
        if (!isCropping && annotations.length > 0) {
          ctx.save();
          ctx.setTransform(1, 0, 0, 1, 0, 0);

          annotations.forEach((ann) => {
            ctx.font = `${ann.size}px Inter, sans-serif`;
            ctx.fillStyle = ann.color;
            ctx.textBaseline = "top";

            const lines = ann.text.split("\n");
            let maxWidth = 0;
            lines.forEach((line) => {
              const metrics = ctx.measureText(line);
              if (metrics.width > maxWidth) maxWidth = metrics.width;
            });

            const padding = 10;
            const lineHeight = ann.size * 1.2;
            const totalHeight = lines.length * lineHeight;
            const totalWidth = maxWidth;

            // V·∫Ω n·ªÅn ch·ªØ
            ctx.fillStyle = ann.bgColor;
            const boxX = ann.x - padding;
            const boxY = ann.y - padding;
            const boxW = totalWidth + padding * 2;
            const boxH = totalHeight + padding * 2;

            ctx.fillRect(boxX, boxY, boxW, boxH);

            // V·∫Ω khung khi ƒëang k√©o/ch·ªçn
            if (activeDragAnnotation && activeDragAnnotation.id === ann.id) {
              ctx.strokeStyle = "#FFC107"; // M√†u v√†ng
              ctx.lineWidth = 3;
              ctx.setLineDash([5, 5]);
              ctx.strokeRect(boxX, boxY, boxW, boxH);
              ctx.setLineDash([]);
            }

            // V·∫Ω ch·ªØ
            ctx.fillStyle = ann.color;
            lines.forEach((line, index) => {
              ctx.fillText(line, ann.x, ann.y + index * lineHeight);
            });
          });

          ctx.restore();
        }

        canvas.style.maxWidth = "100%";
        canvas.style.maxHeight = "100%";
      }

      // --- Ch·ª©c nƒÉng Ch·ªØ (Annotation) M·ªöI ---

      /**
       * ƒê·ªìng b·ªô h√≥a thu·ªôc t√≠nh c·ªßa annotation ƒëang ch·ªçn v√†o c√°c √¥ input.
       * @param {Object} annotation - Annotation object to sync from, or null to reset inputs.
       */
      function syncActiveAnnotationToInputs(annotation) {
        const defaultText = document.getElementById("textInput").value; // Keep current text as default for new annotation

        if (annotation) {
          document.getElementById("textInput").value = annotation.text;
          document.getElementById("fontSize").value = annotation.size;
          document.getElementById("textColor").value = annotation.color;
          document.getElementById("textBgColor").value = annotation.bgColor;
          document.getElementById("textPositionX").value = Math.round(
            annotation.x
          );
          document.getElementById("textPositionY").value = Math.round(
            annotation.y
          );
          activeTextIdSpan.textContent = annotation.id.substring(0, 8) + "...";
          annotationInfoDiv.classList.remove("hidden");
        } else {
          // Khi kh√¥ng c√≥ annotation n√†o ƒë∆∞·ª£c ch·ªçn, ch·ªâ reset UI feedback
          // Gi·ªØ l·∫°i c√°c gi√° tr·ªã input ƒë·ªÉ d√πng cho annotation m·ªõi
          activeTextIdSpan.textContent = "Kh√¥ng";
          annotationInfoDiv.classList.add("hidden");
        }
      }

      /**
       * ƒê·ªìng b·ªô h√≥a c√°c √¥ input v√†o thu·ªôc t√≠nh c·ªßa annotation ƒëang ch·ªçn (real-time editing).
       */
      function syncInputsToActiveAnnotation() {
        if (!activeDragAnnotation) {
          // Kh√¥ng l√†m g√¨ n·∫øu kh√¥ng c√≥ l·ªõp ch·ªØ n√†o ƒë∆∞·ª£c ch·ªçn
          return;
        }

        activeDragAnnotation.text = document.getElementById("textInput").value;
        activeDragAnnotation.size =
          parseInt(document.getElementById("fontSize").value) || 30;
        activeDragAnnotation.color = document.getElementById("textColor").value;
        activeDragAnnotation.bgColor =
          document.getElementById("textBgColor").value;
        activeDragAnnotation.x =
          parseInt(document.getElementById("textPositionX").value) || 0;
        activeDragAnnotation.y =
          parseInt(document.getElementById("textPositionY").value) || 0;

        drawCanvas(originalImage);
      }

      /**
       * Th√™m m·ªôt ch√∫ th√≠ch vƒÉn b·∫£n m·ªõi v√†o m·∫£ng.
       */
      function addTextAnnotation() {
        if (!originalImage) return;

        const text = document.getElementById("textInput").value.trim();
        if (!text) return;

        const size = parseInt(document.getElementById("fontSize").value) || 30;
        const color = document.getElementById("textColor").value;
        const bgColor = document.getElementById("textBgColor").value;
        const x =
          parseInt(document.getElementById("textPositionX").value) || 50;
        const y =
          parseInt(document.getElementById("textPositionY").value) || 50;

        const newId =
          Date.now().toString(36) + Math.random().toString(36).substring(2);

        const newAnnotation = {
          id: newId,
          text: text,
          size: size,
          color: color,
          bgColor: bgColor,
          x: x,
          y: y,
        };

        annotations.push(newAnnotation);

        // X√≥a input text sau khi th√™m ƒë·ªÉ chu·∫©n b·ªã cho annotation ti·∫øp theo
        document.getElementById("textInput").value = "";

        // H·ªßy ch·ªçn l·ªõp ch·ªØ hi·ªán t·∫°i
        activeDragAnnotation = null;
        syncActiveAnnotationToInputs(null);

        drawCanvas(originalImage);
      }

      /**
       * X√≥a ch√∫ th√≠ch ƒëang ƒë∆∞·ª£c k√©o/ch·ªçn.
       */
      function deleteActiveAnnotation() {
        if (!activeDragAnnotation) return;

        const index = annotations.findIndex(
          (ann) => ann.id === activeDragAnnotation.id
        );
        if (index > -1) {
          annotations.splice(index, 1);
        }

        activeDragAnnotation = null;
        syncActiveAnnotationToInputs(null); // Reset annotation controls UI
        drawCanvas(originalImage);
      }

      /**
       * Ki·ªÉm tra xem m·ªôt ƒëi·ªÉm (t·ªça ƒë·ªô canvas) c√≥ n·∫±m trong v√πng annotation kh√¥ng.
       */
      function isPointInAnnotation(pointX, pointY, ann) {
        const tempCtx = canvas.getContext("2d");
        tempCtx.font = `${ann.size}px Inter, sans-serif`;
        const lines = ann.text.split("\n");
        let maxWidth = 0;
        lines.forEach((line) => {
          const metrics = tempCtx.measureText(line);
          if (metrics.width > maxWidth) maxWidth = metrics.width;
        });

        const padding = 10;
        const lineHeight = ann.size * 1.2;
        const totalHeight = lines.length * lineHeight;
        const totalWidth = maxWidth;

        // Bounding Box Coordinates (bao g·ªìm c·∫£ padding c·ªßa background)
        const boxX = ann.x - padding;
        const boxY = ann.y - padding;
        const boxW = totalWidth + padding * 2;
        const boxH = totalHeight + padding * 2;

        return (
          pointX >= boxX &&
          pointX <= boxX + boxW &&
          pointY >= boxY &&
          pointY <= boxY + boxH
        );
      }

      // --- Event Listeners for Dragging and Selection ---

      // MOUSE DOWN: B·∫Øt ƒë·∫ßu k√©o ch·ªØ ho·∫∑c b·∫Øt ƒë·∫ßu c·∫Øt
      canvas.addEventListener("mousedown", (e) => {
        if (!originalImage) return;

        const { x: scaledX, y: scaledY } = getCanvasCoords(
          e.clientX,
          e.clientY
        );

        // 1. Logic Cropping
        if (isCropping) {
          cropStart.x = scaledX;
          cropStart.y = scaledY;
          cropRect = null;
          cropApplyBtn.disabled = true;
          cropApplyBtn.classList.add("opacity-50", "cursor-not-allowed");
          syncCropInputsToRect();
          drawCanvas(originalImage);
          return;
        }

        // 2. Logic Text Dragging / Selection
        let clickedAnnotation = null;
        for (let i = annotations.length - 1; i >= 0; i--) {
          const ann = annotations[i];
          if (isPointInAnnotation(scaledX, scaledY, ann)) {
            clickedAnnotation = ann;
            break;
          }
        }

        if (clickedAnnotation) {
          isTextDragging = true;
          activeDragAnnotation = clickedAnnotation;

          // ƒê·ªìng b·ªô thu·ªôc t√≠nh c·ªßa l·ªõp ch·ªØ ƒëang ch·ªçn l√™n UI controls
          syncActiveAnnotationToInputs(activeDragAnnotation);

          dragOffsetX = scaledX - activeDragAnnotation.x;
          dragOffsetY = scaledY - activeDragAnnotation.y;

          canvas.style.cursor = "move";
          e.preventDefault();
          drawCanvas(originalImage);
        } else {
          // N·∫øu kh√¥ng click v√†o annotation n√†o, h·ªßy ch·ªçn (n·∫øu c√≥)
          activeDragAnnotation = null;
          syncActiveAnnotationToInputs(null); // Clears UI feedback
          drawCanvas(originalImage);
        }
      });

      // MOUSE MOVE: K√©o ch·ªØ ho·∫∑c v·∫Ω v√πng c·∫Øt
      canvas.addEventListener("mousemove", (e) => {
        // Thay ƒë·ªïi cursor n·∫øu di chu·ªôt qua ch·ªØ m√† kh√¥ng click
        if (!isCropping && !isTextDragging && annotations.length > 0) {
          const { x: scaledX, y: scaledY } = getCanvasCoords(
            e.clientX,
            e.clientY
          );
          let overAnnotation = false;
          for (let i = annotations.length - 1; i >= 0; i--) {
            if (isPointInAnnotation(scaledX, scaledY, annotations[i])) {
              overAnnotation = true;
              break;
            }
          }
          canvas.style.cursor = overAnnotation ? "grab" : "default";
        }

        if (!originalImage || e.buttons !== 1) return;

        const { x: scaledCurrentX, y: scaledCurrentY } = getCanvasCoords(
          e.clientX,
          e.clientY
        );

        if (isCropping) {
          // Logic Drawing Crop Area (Gi·ªØ nguy√™n)
          const clampedX = Math.min(Math.max(0, scaledCurrentX), canvas.width);
          const clampedY = Math.min(Math.max(0, scaledCurrentY), canvas.height);

          const x = Math.min(cropStart.x, clampedX);
          const y = Math.min(cropStart.y, clampedY);
          const w = Math.abs(cropStart.x - clampedX);
          const h = Math.abs(cropStart.y - clampedY);

          if (w > 10 && h > 10 && x < canvas.width && y < canvas.height) {
            cropRect = { x: x, y: y, w: w, h: h };
            syncCropInputsToRect();
            cropApplyBtn.disabled = false;
            cropApplyBtn.classList.remove("opacity-50", "cursor-not-allowed");
          } else {
            cropRect = null;
            syncCropInputsToRect();
            cropApplyBtn.disabled = true;
            cropApplyBtn.classList.add("opacity-50", "cursor-not-allowed");
          }
          drawCanvas(originalImage);
        } else if (isTextDragging && activeDragAnnotation) {
          // Logic Text Dragging
          let newX = scaledCurrentX - dragOffsetX;
          let newY = scaledCurrentY - dragOffsetY;

          // Gi·ªõi h·∫°n trong canvas
          activeDragAnnotation.x = Math.max(
            0,
            Math.min(newX, canvas.width - 10)
          );
          activeDragAnnotation.y = Math.max(
            0,
            Math.min(newY, canvas.height - 10)
          );

          // C·∫≠p nh·∫≠t input UI (Ch·ªâ khi ƒëang k√©o)
          document.getElementById("textPositionX").value = Math.round(
            activeDragAnnotation.x
          );
          document.getElementById("textPositionY").value = Math.round(
            activeDragAnnotation.y
          );

          drawCanvas(originalImage);
          canvas.style.cursor = "grabbing";
        }
      });

      // MOUSE UP: K·∫øt th√∫c k√©o
      document.addEventListener("mouseup", () => {
        if (isTextDragging) {
          isTextDragging = false;

          // Sau khi th·∫£, v·∫´n gi·ªØ l·ªõp ch·ªØ ƒë√≥ l√† ACTIVE ƒë·ªÉ ch·ªânh s·ª≠a thu·ªôc t√≠nh
          if (activeDragAnnotation) {
            syncActiveAnnotationToInputs(activeDragAnnotation);
          }

          // C·∫≠p nh·∫≠t l·∫°i cursor
          const { x: scaledX, y: scaledY } = getCanvasCoords(
            event.clientX,
            event.clientY
          );
          let overAnnotation = false;
          for (let i = annotations.length - 1; i >= 0; i--) {
            if (isPointInAnnotation(scaledX, scaledY, annotations[i])) {
              overAnnotation = true;
              break;
            }
          }
          canvas.style.cursor = overAnnotation ? "grab" : "default";
        }
      });

      // --- Ch·ª©c nƒÉng C·∫Øt (Gi·ªØ nguy√™n) ---

      function syncCropInputsToRect() {
        if (!cropRect) {
          document.getElementById("cropX").value = 0;
          document.getElementById("cropY").value = 0;
          document.getElementById("cropW").value = 0;
          document.getElementById("cropH").value = 0;
          return;
        }
        document.getElementById("cropX").value = Math.round(cropRect.x);
        document.getElementById("cropY").value = Math.round(cropRect.y);
        document.getElementById("cropW").value = Math.round(cropRect.w);
        document.getElementById("cropH").value = Math.round(cropRect.h);
      }

      function updateCropRectFromInputs() {
        if (!originalImage || !isCropping) return;

        const x = Math.min(
          Math.max(0, parseInt(document.getElementById("cropX").value) || 0),
          canvas.width
        );
        const y = Math.min(
          Math.max(0, parseInt(document.getElementById("cropY").value) || 0),
          canvas.height
        );
        const w = Math.min(
          Math.max(0, parseInt(document.getElementById("cropW").value) || 0),
          canvas.width - x
        );
        const h = Math.min(
          Math.max(0, parseInt(document.getElementById("cropH").value) || 0),
          canvas.height - y
        );

        if (w > 10 && h > 10 && x < canvas.width && y < canvas.height) {
          cropRect = { x: x, y: y, w: w, h: h };
          syncCropInputsToRect();
          cropApplyBtn.disabled = false;
          cropApplyBtn.classList.remove("opacity-50", "cursor-not-allowed");
        } else {
          cropRect = null;
          syncCropInputsToRect();
          cropApplyBtn.disabled = true;
          cropApplyBtn.classList.add("opacity-50", "cursor-not-allowed");
        }
        drawCanvas(originalImage);
      }

      function toggleCropMode() {
        if (!originalImage) return;

        isCropping = !isCropping;
        const cropBtn = document.getElementById("cropModeBtn");
        const cropInputsDiv = document.getElementById("cropInfoInputs");

        if (isCropping) {
          isTextDragging = false;
          cropBtn.classList.replace("btn-secondary", "bg-red-500");
          cropBtn.classList.add("text-white");
          cropBtn.textContent = "‚ùå H·ªßy C·∫Øt";
          canvas.style.cursor = "crosshair";
          cropApplyBtn.disabled = true;
          cropApplyBtn.classList.add("opacity-50", "cursor-not-allowed");
          cropRect = null;
          syncCropInputsToRect();
          cropInputsDiv.classList.remove("invisible");
        } else {
          cropBtn.classList.replace("bg-red-500", "btn-secondary");
          cropBtn.classList.remove("text-white");
          cropBtn.textContent = "‚úÇÔ∏è Ch·∫ø ƒê·ªô C·∫Øt";
          canvas.style.cursor = "default";
          cropApplyBtn.disabled = true;
          cropApplyBtn.classList.add("opacity-50", "cursor-not-allowed");
          cropRect = null;
          cropInputsDiv.classList.add("invisible");
        }
        drawCanvas(originalImage);
      }

      function performCrop() {
        if (!originalImage || !cropRect) return;

        const widthAfterRotate =
          rotationAngle % 180 !== 0
            ? originalImage.height
            : originalImage.width;
        const heightAfterRotate =
          rotationAngle % 180 !== 0
            ? originalImage.width
            : originalImage.height;

        const fullTransformCanvas = document.createElement("canvas");
        const ftCtx = fullTransformCanvas.getContext("2d");
        fullTransformCanvas.width = widthAfterRotate;
        fullTransformCanvas.height = heightAfterRotate;

        ftCtx.translate(
          fullTransformCanvas.width / 2,
          fullTransformCanvas.height / 2
        );
        ftCtx.rotate((rotationAngle * Math.PI) / 180);
        ftCtx.scale(flipH, 1);
        ftCtx.drawImage(
          originalImage,
          -originalImage.width / 2,
          -originalImage.height / 2,
          originalImage.width,
          originalImage.height
        );
        ftCtx.restore();

        const ratioX = fullTransformCanvas.width / canvas.width;
        const ratioY = fullTransformCanvas.height / canvas.height;

        const cropX = cropRect.x * ratioX;
        const cropY = cropRect.y * ratioY;
        const cropW = cropRect.w * ratioX;
        const cropH = cropRect.h * ratioY;

        const finalCanvas = document.createElement("canvas");
        const finalCtx = finalCanvas.getContext("2d");
        finalCanvas.width = cropW;
        finalCanvas.height = cropH;

        finalCtx.drawImage(
          fullTransformCanvas,
          cropX,
          cropY,
          cropW,
          cropH,
          0,
          0,
          cropW,
          cropH
        );

        const newImg = new Image();
        newImg.onload = function () {
          originalImage = newImg;

          rotationAngle = 0;
          flipH = 1;

          toggleCropMode();
          cropRect = null;

          // C·∫≠p nh·∫≠t l·∫°i t·ªça ƒë·ªô annotation cho ·∫£nh ƒë√£ c·∫Øt
          annotations.forEach((ann) => {
            ann.x = ann.x * (newImg.width / cropW);
            ann.y = ann.y * (newImg.height / cropH);
          });

          applyFilters();
        };
        newImg.src = finalCanvas.toDataURL();
      }

      // --- H√†m T·∫£i ·∫¢nh (Gi·ªØ nguy√™n) ---

      function downloadImage() {
        if (!originalImage) return;

        const finalCanvas = document.createElement("canvas");
        const finalCtx = finalCanvas.getContext("2d");

        const isRotated = rotationAngle % 180 !== 0;
        finalCanvas.width = isRotated
          ? originalImage.height
          : originalImage.width;
        finalCanvas.height = isRotated
          ? originalImage.width
          : originalImage.height;

        const filterString = canvas.style.filter;
        finalCtx.filter = filterString;

        finalCtx.translate(finalCanvas.width / 2, finalCanvas.height / 2);
        finalCtx.rotate((rotationAngle * Math.PI) / 180);
        finalCtx.scale(flipH, 1);

        let drawX = -originalImage.width / 2;
        let drawY = -originalImage.height / 2;
        let drawW = originalImage.width;
        let drawH = originalImage.height;
        finalCtx.drawImage(originalImage, drawX, drawY, drawW, drawH);

        finalCtx.restore();

        finalCtx.save();
        finalCtx.setTransform(1, 0, 0, 1, 0, 0);

        annotations.forEach((ann) => {
          finalCtx.font = `${ann.size}px Inter, sans-serif`;
          finalCtx.textBaseline = "top";

          const lines = ann.text.split("\n");
          let maxWidth = 0;
          lines.forEach((line) => {
            const metrics = finalCtx.measureText(line);
            if (metrics.width > maxWidth) maxWidth = metrics.width;
          });

          const padding = 10;
          const lineHeight = ann.size * 1.2;
          const totalHeight = lines.length * lineHeight;
          const totalWidth = maxWidth;

          finalCtx.fillStyle = ann.bgColor;
          finalCtx.fillRect(
            ann.x - padding,
            ann.y - padding,
            totalWidth + padding * 2,
            totalHeight + padding * 2
          );

          finalCtx.fillStyle = ann.color;
          lines.forEach((line, index) => {
            finalCtx.fillText(line, ann.x, ann.y + index * lineHeight);
          });
        });
        finalCtx.restore();

        const format = downloadFormat.value;
        const extension = format.split("/")[1];

        finalCanvas.toBlob(
          function (blob) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `edited_image_${Date.now()}.${extension}`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
          },
          format,
          0.9
        );
      }

      // --- H√†m X·ª≠ L√Ω AI Image Generation (Gi·ªØ nguy√™n) ---

      function getImageBase64() {
        if (!originalImage) return null;

        const tempCanvas = document.createElement("canvas");
        const tempCtx = tempCanvas.getContext("2d");

        const isRotated = rotationAngle % 180 !== 0;
        tempCanvas.width = isRotated
          ? originalImage.height
          : originalImage.width;
        tempCanvas.height = isRotated
          ? originalImage.width
          : originalImage.height;

        tempCtx.filter = canvas.style.filter;

        tempCtx.translate(tempCanvas.width / 2, tempCanvas.height / 2);
        tempCtx.rotate((rotationAngle * Math.PI) / 180);
        tempCtx.scale(flipH, 1);
        tempCtx.drawImage(
          originalImage,
          -originalImage.width / 2,
          -originalImage.height / 2,
          originalImage.width,
          originalImage.height
        );
        tempCtx.restore();

        // V·∫Ω Annotations (Ch·ªØ) l√™n ·∫£nh ƒë·ªÉ g·ª≠i cho AI
        tempCtx.save();
        tempCtx.setTransform(1, 0, 0, 1, 0, 0);
        annotations.forEach((ann) => {
          tempCtx.font = `${ann.size}px Inter, sans-serif`;
          tempCtx.textBaseline = "top";

          const lines = ann.text.split("\n");
          let maxWidth = 0;
          lines.forEach((line) => {
            const metrics = tempCtx.measureText(line);
            if (metrics.width > maxWidth) maxWidth = metrics.width;
          });

          const padding = 10;
          const lineHeight = ann.size * 1.2;
          const totalHeight = lines.length * lineHeight;
          const totalWidth = maxWidth;

          tempCtx.fillStyle = ann.bgColor;
          tempCtx.fillRect(
            ann.x - padding,
            ann.y - padding,
            totalWidth + padding * 2,
            totalHeight + padding * 2
          );

          tempCtx.fillStyle = ann.color;
          lines.forEach((line, index) => {
            tempCtx.fillText(line, ann.x, ann.y + index * lineHeight);
          });
        });
        tempCtx.restore();

        const dataURL = tempCanvas.toDataURL("image/png");
        return dataURL.split(",")[1];
      }

      async function generateAIImage() {
        const prompt = document.getElementById("aiPrompt").value.trim();
        const resultDiv = document.getElementById("aiResult");
        const generateBtn = document.getElementById("generateBtn");

        if (!prompt) {
          resultDiv.innerHTML = `<p class="text-red-400 text-sm text-center p-4">Vui l√≤ng nh·∫≠p m√¥ t·∫£ ƒë·ªÉ t·∫°o ·∫£nh!</p>`;
          return;
        }

        const base64ImageData = getImageBase64();
        let contents = [{ parts: [{ text: prompt }] }];
        let modalityText = "M√¥ h√¨nh AI t·∫°o ·∫£nh Text-to-Image...";

        if (base64ImageData) {
          contents = [
            {
              parts: [
                { text: prompt },
                {
                  inlineData: {
                    mimeType: "image/png",
                    data: base64ImageData,
                  },
                },
              ],
            },
          ];
          modalityText = "M√¥ h√¨nh AI ch·ªânh s·ª≠a ·∫£nh Image-to-Image...";
        }

        generateBtn.disabled = true;
        generateBtn.innerHTML = `<div class="flex items-center justify-center space-x-2"><div class="spinner"></div><span>${modalityText}</span></div>`;
        resultDiv.innerHTML =
          '<div class="flex items-center justify-center h-full"><div class="spinner border-t-white"></div></div>';

        try {
          const payload = {
            contents: contents,
            generationConfig: {
              responseModalities: ["TEXT", "IMAGE"],
            },
            systemInstruction: systemInstruction,
          };

          const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;

          let response;
          let delay = 1000;
          const maxRetries = 5;

          for (let i = 0; i < maxRetries; i++) {
            response = await fetch(apiUrl, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload),
            });

            if (response.ok) {
              break;
            }
            if (response.status === 429 && i < maxRetries - 1) {
              await new Promise((resolve) => setTimeout(resolve, delay));
              delay *= 2;
            } else {
              throw new Error(`API returned status ${response.status}`);
            }
          }

          if (!response || !response.ok) {
            throw new Error("L·ªói m·∫°ng ho·∫∑c server API.");
          }

          const result = await response.json();
          const base64Data = result?.candidates?.[0]?.content?.parts?.find(
            (p) => p.inlineData
          )?.inlineData?.data;

          if (base64Data) {
            const imageUrl = `data:image/png;base64,${base64Data}`;

            resultDiv.innerHTML = `
                        <img src="${imageUrl}" alt="AI Generated Image" class="w-full h-full object-cover rounded-xl" />
                    `;

            const downloadAI = document.createElement("a");
            downloadAI.href = imageUrl;
            downloadAI.download = `ai_image_${Date.now()}.png`;
            downloadAI.className = "btn-primary mt-2 block text-center";
            downloadAI.textContent = "T·∫£i ·∫¢nh AI";

            const container = document.createElement("div");
            container.className =
              "absolute bottom-3 left-0 right-0 p-3 bg-black bg-opacity-50 flex justify-center rounded-b-xl";
            container.appendChild(downloadAI);
            resultDiv.appendChild(container);
          } else {
            resultDiv.innerHTML = `<p class="text-red-400 text-sm text-center p-4">Kh√¥ng th·ªÉ t·∫°o ·∫£nh. Vui l√≤ng th·ª≠ l·∫°i v·ªõi m√¥ t·∫£ kh√°c.</p>`;
          }
        } catch (error) {
          console.error("AI Image Generation Error:", error);
          resultDiv.innerHTML = `<p class="text-red-400 text-sm text-center p-4">L·ªói: ${error.message}. Ki·ªÉm tra console ƒë·ªÉ bi·∫øt chi ti·∫øt.</p>`;
        } finally {
          generateBtn.disabled = false;
          generateBtn.innerHTML = "T·∫°o/Ch·ªânh S·ª≠a ·∫¢nh M·ªõi";
        }
      }
    </script>
  </body>
</html>
