<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tr√¨nh Ch·ªânh S·ª≠a ·∫¢nh Th√¥ng Minh</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: "Inter", sans-serif;
        background-color: #f3f4f6;
      }
      /* Custom scrollbar for better aesthetics */
      ::-webkit-scrollbar {
        width: 8px;
      }
      ::-webkit-scrollbar-track {
        background: #e5e7eb;
      }
      ::-webkit-scrollbar-thumb {
        background: #9ca3af;
        border-radius: 4px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #6b7280;
      }

      /* Canvas container styles */
      #previewContainer {
        min-height: 400px;
        display: flex;
        justify-content: center;
        align-items: center;
        background-color: #e5e7eb;
        border: 2px dashed #9ca3af;
        border-radius: 0.75rem;
        overflow: hidden;
        position: relative;
      }
      #imageCanvas {
        max-width: 100%;
        max-height: 100%;
        display: none; /* Hidden until image is loaded */
        cursor: default; /* Changed default cursor */
      }
      .control-group {
        @apply flex flex-col space-y-2 p-4 bg-white rounded-xl shadow-lg transition duration-300 hover:shadow-xl;
      }
      .btn-primary {
        @apply bg-indigo-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md hover:bg-indigo-700 transition duration-150 ease-in-out;
      }
      .btn-secondary {
        @apply bg-gray-200 text-gray-800 font-semibold py-2 px-4 rounded-lg shadow-md hover:bg-gray-300 transition duration-150 ease-in-out;
      }
      /* Styles for the loading spinner */
      .spinner {
        border: 4px solid rgba(255, 255, 255, 0.3);
        border-top: 4px solid #ffffff;
        border-radius: 50%;
        width: 30px;
        height: 30px;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
      .ai-result {
        aspect-ratio: 1/1;
        background-color: #1f2937;
        border-radius: 0.75rem;
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: hidden;
        position: relative; /* For download button positioning */
      }
      .visible {
        visibility: visible;
      }
      .invisible {
        visibility: hidden;
      }
    </style>
  </head>
  <body class="p-4 md:p-8">
    <div class="max-w-6xl mx-auto">
      <h1 class="text-3xl font-bold text-gray-900 mb-6 border-b pb-2">
        üñºÔ∏è Tr√¨nh Ch·ªânh S·ª≠a ·∫¢nh Th√¥ng Minh
      </h1>

      <div id="editor-section" class="grid grid-cols-1 lg:grid-cols-3 gap-8">
        <!-- C·ªôt 1: Controls -->
        <div class="lg:col-span-1 space-y-6">
          <!-- Nh√≥m 1: T·∫£i ·∫¢nh v√† T·∫£i Xu·ªëng -->
          <div class="control-group">
            <h2 class="text-xl font-semibold mb-3 text-indigo-600">
              1. Qu·∫£n L√Ω ·∫¢nh
            </h2>
            <label
              for="imageUpload"
              class="btn-primary block text-center cursor-pointer"
            >
              Ch·ªçn v√† T·∫£i ·∫¢nh L√™n
            </label>
            <input
              type="file"
              id="imageUpload"
              accept="image/*"
              class="hidden"
              onchange="handleImageUpload(event)"
            />

            <button
              id="downloadBtn"
              class="btn-secondary w-full opacity-50 cursor-not-allowed"
              disabled
              onclick="downloadImage()"
            >
              üì• T·∫£i ·∫¢nh ƒê√£ Ch·ªânh S·ª≠a
            </button>
            <select
              id="downloadFormat"
              class="w-full p-2 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500"
            >
              <option value="image/png">PNG</option>
              <option value="image/jpeg">JPEG</option>
              <option value="image/gif">GIF</option>
              <option value="image/webp">WEBP</option>
            </select>
          </div>

          <!-- Nh√≥m 2: ƒêi·ªÅu Ch·ªânh C∆° B·∫£n (Sliders) -->
          <div class="control-group">
            <h2 class="text-xl font-semibold mb-3 text-indigo-600">
              2. ƒêi·ªÅu Ch·ªânh C∆° B·∫£n
            </h2>

            <div id="controls-list" class="space-y-4">
              <!-- Brightness -->
              <div class="flex flex-col">
                <label
                  for="brightness"
                  class="font-medium text-gray-700 flex justify-between"
                >
                  ƒê·ªô S√°ng: <span id="brightnessValue">100%</span>
                </label>
                <input
                  type="range"
                  id="brightness"
                  min="0"
                  max="200"
                  value="100"
                  class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                  oninput="applyFilters()"
                />
              </div>

              <!-- Contrast -->
              <div class="flex flex-col">
                <label
                  for="contrast"
                  class="font-medium text-gray-700 flex justify-between"
                >
                  ƒê·ªô T∆∞∆°ng Ph·∫£n: <span id="contrastValue">100%</span>
                </label>
                <input
                  type="range"
                  id="contrast"
                  min="0"
                  max="200"
                  value="100"
                  class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                  oninput="applyFilters()"
                />
              </div>

              <!-- Blur -->
              <div class="flex flex-col">
                <label
                  for="blur"
                  class="font-medium text-gray-700 flex justify-between"
                >
                  L√†m M·ªù (Blur): <span id="blurValue">0px</span>
                </label>
                <input
                  type="range"
                  id="blur"
                  min="0"
                  max="10"
                  value="0"
                  class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                  oninput="applyFilters()"
                />
              </div>
            </div>
          </div>

          <!-- Nh√≥m 3: Hi·ªáu ·ª®ng v√† L·∫≠t Xoay (Buttons) -->
          <div class="control-group">
            <h2 class="text-xl font-semibold mb-3 text-indigo-600">
              3. Bi·∫øn ƒê·ªïi & C·∫Øt
            </h2>
            <div class="grid grid-cols-2 gap-3">
              <button class="btn-secondary" onclick="applyGrayscale()">
                ‚ö´ Chuy·ªÉn ƒêen Tr·∫Øng
              </button>
              <button class="btn-secondary" onclick="resetFilters()">
                üîÑ ƒê·∫∑t L·∫°i Hi·ªáu ·ª®ng
              </button>
              <button class="btn-secondary" onclick="rotateImage(90)">
                ‚Ü©Ô∏è Xoay (90¬∞)
              </button>
              <button class="btn-secondary" onclick="flipImage('horizontal')">
                ‚ÜîÔ∏è L·∫≠t Ngang
              </button>

              <!-- Crop Buttons Added Here -->
              <button
                id="cropModeBtn"
                class="btn-secondary col-span-2"
                onclick="toggleCropMode()"
              >
                ‚úÇÔ∏è Ch·∫ø ƒê·ªô C·∫Øt
              </button>
              <button
                id="applyCropBtn"
                class="btn-primary col-span-2 opacity-50 cursor-not-allowed"
                disabled
                onclick="performCrop()"
              >
                ‚úÖ √Åp D·ª•ng C·∫Øt
              </button>
            </div>
          </div>
        </div>

        <!-- C·ªôt 2: Preview ·∫¢nh -->
        <div class="lg:col-span-2">
          <!-- NEW: Hi·ªÉn th·ªã k√≠ch th∆∞·ªõc v√πng c·∫Øt -->
          <div
            id="cropInfo"
            class="text-sm font-medium text-gray-700 mb-2 invisible"
          >
            V√πng ch·ªçn: R·ªông <span id="cropWidth">0</span>px, Cao
            <span id="cropHeight">0</span>px
          </div>

          <div id="previewContainer" class="w-full">
            <p
              id="placeholderText"
              class="text-gray-500 text-lg p-10 text-center"
            >
              Vui l√≤ng t·∫£i ·∫£nh l√™n ƒë·ªÉ b·∫Øt ƒë·∫ßu ch·ªânh s·ª≠a.<br />
              (·∫¢nh s·∫Ω ƒë∆∞·ª£c hi·ªÉn th·ªã v√† ch·ªânh s·ª≠a t·∫°i ƒë√¢y)
            </p>
            <canvas id="imageCanvas"></canvas>
          </div>
        </div>
      </div>

      <!-- Section: AI Image Generation -->
      <div
        class="mt-12 p-6 bg-white rounded-xl shadow-2xl border border-indigo-100"
      >
        <h2 class="text-2xl font-bold text-indigo-600 mb-4 flex items-center">
          ‚ú® T√≠nh NƒÉng Th√¥ng Minh: Ch·ªânh S·ª≠a ·∫¢nh b·∫±ng AI
        </h2>
        <p class="text-gray-600 mb-4">
          M√¥ h√¨nh AI (<span class="font-semibold text-indigo-500"
            >gemini-2.5-flash-image-preview</span
          >) s·∫Ω s·ª≠ d·ª•ng ·∫£nh hi·ªán t·∫°i tr√™n canvas l√†m ƒë·∫ßu v√†o v√† bi·∫øn ƒë·ªïi theo m√¥
          t·∫£ c·ªßa b·∫°n. **üí° G·ª£i √Ω:** B·∫°n c√≥ th·ªÉ m√¥ t·∫£ chi ti·∫øt v·ªÅ **g√≥c nh√¨n**
          (v√≠ d·ª•: g√≥c th·∫•p 150cm), **b·ªë c·ª•c**, v√† **√°nh s√°ng** ƒë·ªÉ ƒë·∫°t k·∫øt qu·∫£
          mong mu·ªën.
        </p>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
          <!-- Input for AI Prompt -->
          <div class="md:col-span-2 space-y-4">
            <textarea
              id="aiPrompt"
              rows="3"
              class="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500"
              placeholder="M√¥ t·∫£ s·ª± thay ƒë·ªïi b·∫°n mu·ªën (v√≠ d·ª•: Thay th·∫ø con m√®o b·∫±ng m·ªôt con ch√≥ husky, l√†m cho b·∫ßu tr·ªùi c√≥ m√†u t√≠m, phong c√°ch ngh·ªá thu·∫≠t pixel)"
            ></textarea>
            <button
              id="generateBtn"
              class="btn-primary w-full"
              onclick="generateAIImage()"
            >
              T·∫°o/Ch·ªânh S·ª≠a ·∫¢nh M·ªõi
            </button>
          </div>

          <!-- AI Result Display -->
          <div class="md:col-span-1">
            <div id="aiResult" class="ai-result">
              <p class="text-gray-400 text-sm text-center p-4">
                ·∫¢nh AI s·∫Ω xu·∫•t hi·ªán t·∫°i ƒë√¢y
              </p>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      // C·∫•u h√¨nh Tailwind cho n√∫t t·∫£i xu·ªëng sau khi AI t·∫°o ·∫£nh
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              primary: "#4f46e5",
              secondary: "#6366f1",
            },
          },
        },
      };

      const canvas = document.getElementById("imageCanvas");
      const ctx = canvas.getContext("2d");
      const placeholderText = document.getElementById("placeholderText");
      const downloadBtn = document.getElementById("downloadBtn");
      const downloadFormat = document.getElementById("downloadFormat");
      const cropApplyBtn = document.getElementById("applyCropBtn");
      const cropInfo = document.getElementById("cropInfo");

      let initialImage = null; // L∆∞u tr·ªØ ·∫£nh g·ªëc l√∫c m·ªõi t·∫£i (cho Reset to√†n b·ªô)
      let originalImage = null; // L∆∞u tr·ªØ ·∫£nh ƒëang ch·ªânh s·ª≠a (sau khi crop)
      let rotationAngle = 0;
      let flipH = 1; // 1 cho b√¨nh th∆∞·ªùng, -1 cho l·∫≠t ngang

      // Tr·∫°ng th√°i C·∫Øt (Crop)
      let isCropping = false;
      let cropStart = { x: 0, y: 0 };
      let cropRect = null; // L∆∞u tr·ªØ h√¨nh ch·ªØ nh·∫≠t c·∫Øt {x, y, w, h} theo t·ªça ƒë·ªô canvas

      // Constants for API calls
      const apiKey = "";
      const model = "gemini-2.5-flash-image-preview"; // Model for Image-to-Image editing

      // Ch·ªâ d·∫´n h·ªá th·ªëng ƒë·ªÉ tƒÉng c∆∞·ªùng ƒë·ªô ch√≠nh x√°c v·ªÅ b·ªë c·ª•c/g√≥c nh√¨n
      const systemInstruction = {
        parts: [
          {
            text: "B·∫°n l√† m·ªôt chuy√™n gia ch·ªânh s·ª≠a ·∫£nh AI. Nhi·ªám v·ª• c·ªßa b·∫°n l√† l·∫•y ·∫£nh ƒë·∫ßu v√†o v√† √°p d·ª•ng c√°c thay ƒë·ªïi ƒë∆∞·ª£c m√¥ t·∫£ trong prompt c·ªßa ng∆∞·ªùi d√πng. H√£y ch√∫ √Ω ƒë·∫∑c bi·ªát ƒë·∫øn c√°c chi ti·∫øt v·ªÅ g√≥c nh√¨n (perspective), ƒë·ªô cao c·ªßa m√°y ·∫£nh (v√≠ d·ª•: 150cm-200cm), v·ªã tr√≠ trung t√¢m c·ªßa ƒë·ªëi t∆∞·ª£ng v√† c√°c y·∫øu t·ªë b·ªë c·ª•c (composition) kh√°c ƒë·ªÉ ƒë·∫£m b·∫£o k·∫øt qu·∫£ ph√π h·ª£p v·ªõi m√¥ t·∫£ nh·∫•t c√≥ th·ªÉ.",
          },
        ],
      };

      // --- H√†m X·ª≠ L√Ω ·∫¢nh C∆° B·∫£n ---

      /**
       * X·ª≠ l√Ω vi·ªác t·∫£i ·∫£nh l√™n v√† kh·ªüi t·∫°o canvas.
       * @param {Event} event S·ª± ki·ªán t·∫£i file.
       */
      function handleImageUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function (e) {
          const img = new Image();
          img.onload = function () {
            initialImage = img;
            originalImage = img;
            rotationAngle = 0;
            flipH = 1;
            cropRect = null;
            isCropping = false;

            // Reset sliders
            document.getElementById("brightness").value = 100;
            document.getElementById("contrast").value = 100;
            document.getElementById("blur").value = 0;
            canvas.style.filter = "";

            // K√≠ch ho·∫°t n√∫t download v√† hi·ªÉn th·ªã canvas
            downloadBtn.disabled = false;
            downloadBtn.classList.remove("opacity-50", "cursor-not-allowed");
            placeholderText.style.display = "none";
            canvas.style.display = "block";

            // V·∫Ω ·∫£nh g·ªëc l·∫ßn ƒë·∫ßu
            drawCanvas(originalImage);
            applyFilters();
          };
          img.src = e.target.result;
        };
        reader.readAsDataURL(file);
      }

      /**
       * C·∫≠p nh·∫≠t c√°c gi√° tr·ªã filter v√† √°p d·ª•ng l√™n canvas.
       */
      function applyFilters() {
        if (!originalImage) return;

        // L·∫•y gi√° tr·ªã t·ª´ sliders v√† c·∫≠p nh·∫≠t hi·ªÉn th·ªã
        const brightness = document.getElementById("brightness").value;
        const contrast = document.getElementById("contrast").value;
        const blur = document.getElementById("blur").value;

        document.getElementById(
          "brightnessValue"
        ).textContent = `${brightness}%`;
        document.getElementById("contrastValue").textContent = `${contrast}%`;
        document.getElementById("blurValue").textContent = `${blur}px`;

        // L·∫•y gi√° tr·ªã grayscale t·ª´ CSS
        const isGrayscale = canvas.style.filter.includes("grayscale(1)");

        // √Åp d·ª•ng CSS filters v√†o canvas
        let filterString = `brightness(${brightness}%) contrast(${contrast}%) blur(${blur}px)`;
        if (isGrayscale) {
          filterString += ` grayscale(1)`;
        }

        canvas.style.filter = filterString.trim();

        // Re-draw the canvas to ensure transformations are correct
        drawCanvas(originalImage);
      }

      /**
       * ƒê·∫∑t l·∫°i t·∫•t c·∫£ c√°c filter v·ªÅ gi√° tr·ªã m·∫∑c ƒë·ªãnh, bao g·ªìm ho√†n t√°c crop.
       */
      function resetFilters() {
        if (!initialImage) return;

        // ƒê·∫∑t l·∫°i Sliders
        document.getElementById("brightness").value = 100;
        document.getElementById("contrast").value = 100;
        document.getElementById("blur").value = 0;

        // ƒê·∫∑t l·∫°i c√°c bi·∫øn ƒë·ªïi
        rotationAngle = 0;
        flipH = 1;

        // ƒê·∫∑t l·∫°i v·ªÅ ·∫£nh g·ªëc ban ƒë·∫ßu (h√¨nh l√∫c ch∆∞a c·∫Øt)
        originalImage = initialImage;

        // ƒê·∫∑t l·∫°i Crop state
        cropRect = null;
        if (isCropping) toggleCropMode();

        // ƒê·∫∑t l·∫°i CSS filter
        canvas.style.filter = "";

        applyFilters();
        drawCanvas(originalImage);
      }

      /**
       * Chuy·ªÉn ƒë·ªïi ·∫£nh sang ƒëen tr·∫Øng ho·∫∑c ng∆∞·ª£c l·∫°i.
       */
      function applyGrayscale() {
        if (!originalImage) return;

        const currentFilter = canvas.style.filter;
        // Toggle grayscale
        if (currentFilter.includes("grayscale(1)")) {
          canvas.style.filter = currentFilter
            .replace("grayscale(1)", "")
            .trim();
        } else {
          canvas.style.filter += " grayscale(1)";
        }

        // Reapply filters to make sure other settings are preserved
        applyFilters();
      }

      /**
       * Xoay ·∫£nh theo g√≥c.
       * @param {number} angle G√≥c xoay (v√≠ d·ª•: 90).
       */
      function rotateImage(angle) {
        if (!originalImage) return;
        rotationAngle = (rotationAngle + angle) % 360;
        drawCanvas(originalImage);
      }

      /**
       * L·∫≠t ·∫£nh theo chi·ªÅu ngang.
       * @param {string} axis Tr·ª•c l·∫≠t ('horizontal').
       */
      function flipImage(axis) {
        if (!originalImage) return;
        if (axis === "horizontal") {
          flipH *= -1;
        }
        drawCanvas(originalImage);
      }

      /**
       * V·∫Ω ·∫£nh l√™n canvas, √°p d·ª•ng xoay v√† l·∫≠t.
       * @param {HTMLImageElement} img ·∫¢nh g·ªëc.
       */
      function drawCanvas(img) {
        if (!img) return;

        // T√≠nh to√°n k√≠ch th∆∞·ªõc canvas m·ªõi sau khi xoay
        const isRotated = rotationAngle % 180 !== 0;
        const newWidth = isRotated ? img.height : img.width;
        const newHeight = isRotated ? img.width : img.height;

        // C·∫≠p nh·∫≠t k√≠ch th∆∞·ªõc canvas
        canvas.width = newWidth;
        canvas.height = newHeight;

        // Thi·∫øt l·∫≠p v·ªã tr√≠ t√¢m xoay
        ctx.clearRect(0, 0, newWidth, newHeight);
        ctx.save();
        ctx.translate(newWidth / 2, newHeight / 2);

        // √Åp d·ª•ng xoay
        ctx.rotate((rotationAngle * Math.PI) / 180);

        // √Åp d·ª•ng l·∫≠t
        ctx.scale(flipH, 1);

        // V·∫Ω ·∫£nh
        let drawX = -img.width / 2;
        let drawY = -img.height / 2;
        let drawW = img.width;
        let drawH = img.height;

        ctx.drawImage(img, drawX, drawY, drawW, drawH);
        ctx.restore();

        // --- DRAW CROP OVERLAY (V·∫Ω l·ªõp ph·ªß khi c·∫Øt) ---
        if (isCropping && cropRect) {
          // ƒê·∫£m b·∫£o kh√¥ng b·ªã ·∫£nh h∆∞·ªüng b·ªüi rotation/scale c·ªßa h√¨nh ·∫£nh
          ctx.save();
          ctx.setTransform(1, 0, 0, 1, 0, 0); // ƒê·∫∑t l·∫°i ma tr·∫≠n bi·∫øn ƒë·ªïi

          ctx.fillStyle = "rgba(0, 0, 0, 0.5)";

          // 1. V·∫Ω 4 h√¨nh ch·ªØ nh·∫≠t ƒë·ªÉ che ƒëi khu v·ª±c b√™n ngo√†i cropRect

          // Top
          ctx.fillRect(0, 0, canvas.width, cropRect.y);
          // Bottom
          ctx.fillRect(
            0,
            cropRect.y + cropRect.h,
            canvas.width,
            canvas.height - (cropRect.y + cropRect.h)
          );
          // Left
          ctx.fillRect(0, cropRect.y, cropRect.x, cropRect.h);
          // Right
          ctx.fillRect(
            cropRect.x + cropRect.w,
            cropRect.y,
            canvas.width - (cropRect.x + cropRect.w),
            cropRect.h
          );

          // 2. V·∫Ω ƒë∆∞·ªùng vi·ªÅn
          ctx.strokeStyle = "#FFFFFF";
          ctx.lineWidth = 2;
          ctx.setLineDash([5, 5]);
          ctx.strokeRect(cropRect.x, cropRect.y, cropRect.w, cropRect.h);
          ctx.setLineDash([]); // Reset line dash

          ctx.restore(); // Kh√¥i ph·ª•c ma tr·∫≠n bi·∫øn ƒë·ªïi
        }

        // C·∫≠p nh·∫≠t k√≠ch th∆∞·ªõc hi·ªÉn th·ªã ƒë·ªÉ fit container
        canvas.style.maxWidth = "100%";
        canvas.style.maxHeight = "100%";
      }

      // --- Ch·ª©c nƒÉng C·∫Øt (Crop) ---

      /**
       * B·∫≠t/t·∫Øt ch·∫ø ƒë·ªô c·∫Øt.
       */
      function toggleCropMode() {
        if (!originalImage) return;

        isCropping = !isCropping;
        const cropBtn = document.getElementById("cropModeBtn");

        if (isCropping) {
          // B·∫≠t ch·∫ø ƒë·ªô c·∫Øt
          cropBtn.classList.replace("btn-secondary", "bg-red-500");
          cropBtn.classList.add("text-white");
          cropBtn.textContent = "‚ùå H·ªßy C·∫Øt";
          canvas.style.cursor = "crosshair";
          cropApplyBtn.disabled = true;
          cropApplyBtn.classList.add("opacity-50", "cursor-not-allowed");
          cropRect = null;
          cropInfo.classList.remove("invisible"); // Hi·ªÉn th·ªã panel k√≠ch th∆∞·ªõc
        } else {
          // T·∫Øt ch·∫ø ƒë·ªô c·∫Øt
          cropBtn.classList.replace("bg-red-500", "btn-secondary");
          cropBtn.classList.remove("text-white");
          cropBtn.textContent = "‚úÇÔ∏è Ch·∫ø ƒê·ªô C·∫Øt";
          canvas.style.cursor = "default";
          cropApplyBtn.disabled = true;
          cropApplyBtn.classList.add("opacity-50", "cursor-not-allowed");
          cropRect = null;
          cropInfo.classList.add("invisible"); // ·∫®n panel k√≠ch th∆∞·ªõc
        }
        drawCanvas(originalImage);
      }

      /**
       * Th·ª±c hi·ªán c·∫Øt ·∫£nh d·ª±a tr√™n v√πng ƒë√£ ch·ªçn.
       */
      function performCrop() {
        if (!originalImage || !cropRect) return;

        // 1. Canvas ƒë·ªÉ ch·ª©a ·∫£nh ƒë√£ bi·∫øn ƒë·ªïi (Rotate, Flip)
        const widthAfterRotate =
          rotationAngle % 180 !== 0
            ? originalImage.height
            : originalImage.width;
        const heightAfterRotate =
          rotationAngle % 180 !== 0
            ? originalImage.width
            : originalImage.height;

        const fullTransformCanvas = document.createElement("canvas");
        const ftCtx = fullTransformCanvas.getContext("2d");
        fullTransformCanvas.width = widthAfterRotate;
        fullTransformCanvas.height = heightAfterRotate;

        // **CH·ªà** √°p d·ª•ng Rotate v√† Flip (kh√¥ng √°p d·ª•ng CSS filter)
        ftCtx.translate(
          fullTransformCanvas.width / 2,
          fullTransformCanvas.height / 2
        );
        ftCtx.rotate((rotationAngle * Math.PI) / 180);
        ftCtx.scale(flipH, 1);
        ftCtx.drawImage(
          originalImage,
          -originalImage.width / 2,
          -originalImage.height / 2,
          originalImage.width,
          originalImage.height
        );
        ftCtx.restore();

        // 2. T√≠nh to√°n t·ª∑ l·ªá gi·ªØa Canvas hi·ªÉn th·ªã v√† ·∫£nh ƒë√£ bi·∫øn ƒë·ªïi (D√πng ƒë·ªÉ chuy·ªÉn t·ªça ƒë·ªô)
        const ratioX = fullTransformCanvas.width / canvas.width;
        const ratioY = fullTransformCanvas.height / canvas.height;

        // 3. T√≠nh to√°n t·ªça ƒë·ªô c·∫Øt trong k√≠ch th∆∞·ªõc ·∫£nh g·ªëc ƒë√£ bi·∫øn ƒë·ªïi
        // Trong h√†m performCrop, cropRect ƒë√£ ·ªü ƒë√∫ng t·ªâ l·ªá canvas n·ªôi b·ªô,
        // n√™n ta ch·ªâ c·∫ßn nh√¢n t·ªâ l·ªá 1:1 gi·ªØa canvas n·ªôi b·ªô v√† ·∫£nh g·ªëc ƒë√£ bi·∫øn ƒë·ªïi.
        const cropX = cropRect.x * ratioX;
        const cropY = cropRect.y * ratioY;
        const cropW = cropRect.w * ratioX;
        const cropH = cropRect.h * ratioY;

        // 4. Canvas cu·ªëi c√πng (Canvas k·∫øt qu·∫£ sau khi c·∫Øt)
        const finalCanvas = document.createElement("canvas");
        const finalCtx = finalCanvas.getContext("2d");
        finalCanvas.width = cropW;
        finalCanvas.height = cropH;

        // C·∫Øt t·ª´ fullTransformCanvas sang finalCanvas
        finalCtx.drawImage(
          fullTransformCanvas,
          cropX,
          cropY,
          cropW,
          cropH, // Source (v√πng c·∫Øt tr√™n ·∫£nh ƒë√£ bi·∫øn ƒë·ªïi)
          0,
          0,
          cropW,
          cropH // Destination (finalCanvas)
        );

        // 5. C·∫≠p nh·∫≠t originalImage th√†nh ·∫£nh ƒë√£ c·∫Øt
        const newImg = new Image();
        newImg.onload = function () {
          originalImage = newImg;

          // ƒê·∫∑t l·∫°i c√°c bi·∫øn ƒë·ªïi v√¨ ch√∫ng ƒë√£ ƒë∆∞·ª£c "ƒë√≥ng g√≥i" v√†o ·∫£nh m·ªõi
          rotationAngle = 0;
          flipH = 1;

          // ƒê·∫∑t l·∫°i Crop Mode v√† v·∫Ω ·∫£nh m·ªõi
          toggleCropMode();
          cropRect = null;
          // Gi·ªØ l·∫°i gi√° tr·ªã filter tr√™n sliders v√† √°p d·ª•ng
          applyFilters();
        };
        newImg.src = finalCanvas.toDataURL();
      }

      // --- Event Listeners for Cropping (ƒê√É S·ª¨A L·ªñI T·ªà L·ªÜ) ---
      canvas.addEventListener("mousedown", (e) => {
        if (!originalImage || !isCropping) return;

        // NEW: L·∫•y t·ª∑ l·ªá scaling gi·ªØa k√≠ch th∆∞·ªõc hi·ªÉn th·ªã (rect) v√† k√≠ch th∆∞·ªõc n·ªôi b·ªô (canvas.width/height)
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;

        // Scale t·ªça ƒë·ªô chu·ªôt t·ª´ k√≠ch th∆∞·ªõc hi·ªÉn th·ªã l√™n k√≠ch th∆∞·ªõc n·ªôi b·ªô
        cropStart.x = e.offsetX * scaleX;
        cropStart.y = e.offsetY * scaleY;

        cropRect = null;
        cropApplyBtn.disabled = true;
        cropApplyBtn.classList.add("opacity-50", "cursor-not-allowed");
        document.getElementById("cropWidth").textContent = "0";
        document.getElementById("cropHeight").textContent = "0";
        drawCanvas(originalImage);
      });

      canvas.addEventListener("mousemove", (e) => {
        if (!originalImage || !isCropping || e.buttons !== 1) return;

        // NEW: L·∫•y t·ª∑ l·ªá scaling gi·ªØa k√≠ch th∆∞·ªõc hi·ªÉn th·ªã (rect) v√† k√≠ch th∆∞·ªõc n·ªôi b·ªô (canvas.width/height)
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;

        // L·∫•y t·ªça ƒë·ªô hi·ªán t·∫°i (t∆∞∆°ng ƒë·ªëi v·ªõi canvas) v√† scale l√™n
        const scaledCurrentX = e.offsetX * scaleX;
        const scaledCurrentY = e.offsetY * scaleY;

        // **C·∫£i thi·ªán ƒë·ªô ch√≠nh x√°c: Gi·ªõi h·∫°n t·ªça ƒë·ªô ƒë√£ scale trong ranh gi·ªõi canvas th·ª±c t·∫ø**
        const clampedX = Math.min(Math.max(0, scaledCurrentX), canvas.width);
        const clampedY = Math.min(Math.max(0, scaledCurrentY), canvas.height);

        // T√≠nh to√°n th√¥ng s·ªë h√¨nh ch·ªØ nh·∫≠t
        const x = Math.min(cropStart.x, clampedX);
        const y = Math.min(cropStart.y, clampedY);
        const w = Math.abs(cropStart.x - clampedX);
        const h = Math.abs(cropStart.y - clampedY);

        if (w > 10 && h > 10) {
          // cropRect ƒë∆∞·ª£c l∆∞u tr·ªØ b·∫±ng t·ªça ƒë·ªô pixel n·ªôi b·ªô, ƒë√£ ƒë∆∞·ª£c scale ch√≠nh x√°c
          cropRect = { x, y, w, h };

          // C·∫≠p nh·∫≠t hi·ªÉn th·ªã k√≠ch th∆∞·ªõc v√πng ch·ªçn (b·∫±ng pixel n·ªôi b·ªô)
          document.getElementById("cropWidth").textContent = Math.round(w);
          document.getElementById("cropHeight").textContent = Math.round(h);
          cropInfo.classList.remove("invisible");

          cropApplyBtn.disabled = false;
          cropApplyBtn.classList.remove("opacity-50", "cursor-not-allowed");
        } else {
          cropRect = null;
          cropInfo.classList.add("invisible");

          cropApplyBtn.disabled = true;
          cropApplyBtn.classList.add("opacity-50", "cursor-not-allowed");
        }

        drawCanvas(originalImage);
      });

      canvas.addEventListener("mouseup", (e) => {
        // No action needed here
      });

      /**
       * T·∫£i ·∫£nh ƒë√£ ch·ªânh s·ª≠a v·ªÅ m√°y.
       */
      function downloadImage() {
        if (!originalImage) return;

        const finalCanvas = document.createElement("canvas");
        const finalCtx = finalCanvas.getContext("2d");

        const isRotated = rotationAngle % 180 !== 0;
        finalCanvas.width = isRotated
          ? originalImage.height
          : originalImage.width;
        finalCanvas.height = isRotated
          ? originalImage.width
          : originalImage.height;

        const filterString = canvas.style.filter;
        finalCtx.filter = filterString;

        finalCtx.translate(finalCanvas.width / 2, finalCanvas.height / 2);
        finalCtx.rotate((rotationAngle * Math.PI) / 180);
        finalCtx.scale(flipH, 1);

        let drawX = -originalImage.width / 2;
        let drawY = -originalImage.height / 2;
        let drawW = originalImage.width;
        let drawH = originalImage.height;
        finalCtx.drawImage(originalImage, drawX, drawY, drawW, drawH);

        const format = downloadFormat.value;
        const extension = format.split("/")[1];

        finalCanvas.toBlob(
          function (blob) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `edited_image_${Date.now()}.${extension}`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
          },
          format,
          0.9
        );
      }

      /**
       * L·∫•y ·∫£nh ƒëang ch·ªânh s·ª≠a tr√™n canvas d∆∞·ªõi d·∫°ng Base64.
       */
      function getImageBase64() {
        if (!originalImage) return null;

        // T·∫°o m·ªôt canvas t·∫°m th·ªùi v·ªõi k√≠ch th∆∞·ªõc ·∫£nh g·ªëc sau khi crop
        const tempCanvas = document.createElement("canvas");
        const tempCtx = tempCanvas.getContext("2d");

        tempCanvas.width = originalImage.width;
        tempCanvas.height = originalImage.height;

        // V·∫Ω ·∫£nh g·ªëc (ƒë√£ crop) l√™n canvas t·∫°m th·ªùi
        tempCtx.drawImage(
          originalImage,
          0,
          0,
          originalImage.width,
          originalImage.height
        );

        // Chuy·ªÉn canvas th√†nh Base64
        const dataURL = tempCanvas.toDataURL("image/png");
        return dataURL.split(",")[1]; // Ch·ªâ l·∫•y ph·∫ßn data
      }

      // --- H√†m X·ª≠ L√Ω AI Image Generation ---

      /**
       * Th·ª±c hi·ªán t·∫°o/ch·ªânh s·ª≠a ·∫£nh t·ª´ m√¥ t·∫£ v√† ·∫£nh ƒë·∫ßu v√†o.
       */
      async function generateAIImage() {
        const prompt = document.getElementById("aiPrompt").value.trim();
        const resultDiv = document.getElementById("aiResult");
        const generateBtn = document.getElementById("generateBtn");

        if (!prompt) {
          resultDiv.innerHTML = `<p class="text-red-400 text-sm text-center p-4">Vui l√≤ng nh·∫≠p m√¥ t·∫£ ƒë·ªÉ t·∫°o ·∫£nh!</p>`;
          return;
        }

        // X·ª≠ l√Ω ·∫£nh ƒë·∫ßu v√†o (Image-to-Image)
        const base64ImageData = getImageBase64();
        let contents = [{ parts: [{ text: prompt }] }];
        let modalityText = "M√¥ h√¨nh AI t·∫°o ·∫£nh Text-to-Image...";

        if (base64ImageData) {
          contents = [
            {
              parts: [
                { text: prompt },
                {
                  inlineData: {
                    mimeType: "image/png",
                    data: base64ImageData,
                  },
                },
              ],
            },
          ];
          modalityText = "M√¥ h√¨nh AI ch·ªânh s·ª≠a ·∫£nh Image-to-Image...";
        }

        // Hi·ªÉn th·ªã tr·∫°ng th√°i t·∫£i
        generateBtn.disabled = true;
        generateBtn.innerHTML = `<div class="flex items-center justify-center space-x-2"><div class="spinner"></div><span>${modalityText}</span></div>`;
        resultDiv.innerHTML =
          '<div class="flex items-center justify-center h-full"><div class="spinner border-t-white"></div></div>';

        try {
          const payload = {
            contents: contents,
            generationConfig: {
              responseModalities: ["TEXT", "IMAGE"],
            },
            systemInstruction: systemInstruction,
          };

          const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;

          let response;
          let delay = 1000;
          const maxRetries = 5;

          // Exponential Backoff implementation
          for (let i = 0; i < maxRetries; i++) {
            response = await fetch(apiUrl, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload),
            });

            if (response.ok) {
              break;
            }
            if (response.status === 429 && i < maxRetries - 1) {
              // Too many requests
              await new Promise((resolve) => setTimeout(resolve, delay));
              delay *= 2;
            } else {
              throw new Error(`API returned status ${response.status}`);
            }
          }

          if (!response || !response.ok) {
            throw new Error("L·ªói m·∫°ng ho·∫∑c server API.");
          }

          const result = await response.json();

          const base64Data = result?.candidates?.[0]?.content?.parts?.find(
            (p) => p.inlineData
          )?.inlineData?.data;

          if (base64Data) {
            const imageUrl = `data:image/png;base64,${base64Data}`;

            resultDiv.innerHTML = `
                        <img src="${imageUrl}" alt="AI Generated Image" class="w-full h-full object-cover rounded-xl" />
                    `;

            // Th√™m n√∫t t·∫£i xu·ªëng cho ·∫£nh AI
            const downloadAI = document.createElement("a");
            downloadAI.href = imageUrl;
            downloadAI.download = `ai_image_${Date.now()}.png`;
            downloadAI.className = "btn-primary mt-2 block text-center";
            downloadAI.textContent = "T·∫£i ·∫¢nh AI";

            // Add download button below the image
            const container = document.createElement("div");
            container.className =
              "absolute bottom-3 left-0 right-0 p-3 bg-black bg-opacity-50 flex justify-center rounded-b-xl";
            container.appendChild(downloadAI);
            resultDiv.appendChild(container);
          } else {
            resultDiv.innerHTML = `<p class="text-red-400 text-sm text-center p-4">Kh√¥ng th·ªÉ t·∫°o ·∫£nh. Vui l√≤ng th·ª≠ l·∫°i v·ªõi m√¥ t·∫£ kh√°c.</p>`;
          }
        } catch (error) {
          console.error("AI Image Generation Error:", error);
          resultDiv.innerHTML = `<p class="text-red-400 text-sm text-center p-4">L·ªói: ${error.message}. Ki·ªÉm tra console ƒë·ªÉ bi·∫øt chi ti·∫øt.</p>`;
        } finally {
          generateBtn.disabled = false;
          generateBtn.innerHTML = "T·∫°o/Ch·ªânh S·ª≠a ·∫¢nh M·ªõi";
        }
      }
    </script>
  </body>
</html>
